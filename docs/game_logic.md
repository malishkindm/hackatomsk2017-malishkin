# Бизнес-логика игры

Все сообщения от сервера клиенту - на английском. Мы приняли решение ориентироваться на клиента, в котором должны быть реализованы словари, в зависимости он настроек системы (конкретно об iOS речь).

## Уведомления

Поскольку серверная часть общается с клиентами по http, инициировать передачу от сервера к клиенту не получится. Для связи сервера с клиентами используются push-уведомления. В качестве сервера трансляции выступает pusher.com. В нем зарегистрировано приложение на мою (vijit@mail.ru) учетку, бесплатный тариф. Ключи прописаны в `.env`.

Ликбез по теме:

[Laravel 5.5 Broadcasting](https://laravel.com/docs/5.5/broadcasting)
[Laravel Echo](https://laravel.ru/posts/655)
[Writing Realtime apps with Laravel 5 and Pusher](https://blog.pusher.com/writing-realtime-apps-with-laravel-5-and-pusher/)
[Laravel chat with Pusher](https://blog.pusher.com/how-to-build-a-laravel-chat-app-with-pusher/)

**Push в Laravel не будет выполняться, если не запущен обработчик очередей!** Так сделано, чтобы не задерживать выполнение скрипта на соединении с Pusher (или другим WebSockets-сервером) и отправкой данных. Т.е. push-уведомление становится фоновой задачей.

Запустить обработчик очереди, как демон - это [отдельная история](https://laravel.com/docs/5.5/queues#running-the-queue-worker). В качестве отладки и на время разработки можно запустить обработчик прям в консоли:

```sh
php artisan queue:work
```

Но на проде такое не прокатит.

Однако, **для текущего проекта нам не нужна постановка в очередь**, т.к. на push-уведомлении основана очередность действий игроков! Нам нужна отправка уведомления в real-time. Поэтому упрощаем все до максимума: никаких Laravel Events, очередей и т.п. После расчета игрового поля отправляем уведомление, ждем, когда оно уйдет и завершаем выполнение скрипта.

### Свой WebSockets-сервер

[Laravel Echo server](https://github.com/tlaverdure/laravel-echo-server)
[Рабочий пример с laravel-echo-server](https://github.com/tonimitrevski/laravel-notification-redis-echo)
[Realtime Apps With Laravel Echo: Tips and Tricks](https://komelin.com/articles/realtime-apps-laravel-echo-tips-and-tricks)

[Тут](https://laracasts.com/discuss/channels/laravel/i-am-thoroughly-confused-with-socketio-laravel-echo-redis-and-laravel-echo-server) см. `socket.js`. Это пример независимого WebSockets-сервера для проверки Redis на предмет появления новых сообщений. В принципе, можно запустить его вместо `laravel-echo-server`, но я не вижу в этом смысла.

[Laravel Echo iOS](https://github.com/val-bubbleflat/laravel-echo-ios)

### Принятые в игре уведомления

На канале могут быть следующие события:

- `offer-accepted` - рассылается, когда два игрока находят наконец друг друга. В данных лежит описание созданной для них игры  и данные игроков.
- `grid-updated` - после очередного хода игрока сервер пересчитывает поле и рассылает его новое состояние
- `game-ended` - игра окончена, в данных - победитель.

## Защита процесса игры

Сам процесс игры не требует аутентификации. Да, это плохо. Но еще хуже, если во-время игры игрок разлогинится, тогда он автоматически проиграл. К тому же каналы уведомлений публичные, я не осилил, как в Pusher сделать приватный канал. Следовательно, зная название канала и не требуя аутентификацию, можно злоупотребить этим знанием: атака MitM со стороны поддельного игрового клиента.

Обходное решение: для каждой игры создается канал с именем типа `game-c5or3W`, через дефис - случайная последовательность.

Внедриться в игру можно как через push-уведомление, так и через POST очередного хода. Следовательно надо передавать ключ игры вместе с данными о сделанном ходе.

Вот почему такой overhead в бизнес-логике игры. Просто не получается сделать ее защищенной через аутентификацию игроков.

## Unit-тесты

Некоторая часть логики покрыта тестами, см. каталог `backend/tests/unit/`. Движок - `PhpUnit`.

## Игровое поле

Левый **нижний** угол - 0:0. Так сделано в угоду iOS-разработки, там такая координатная сетка.

Состояние ячейки может быть: свободная, занята первым или вторым игроком.

Каждый ход логируется в базу. После каждого хода делается снимок поля (описание состояния ячеек и у кого следующий ход), он пишется в базу. Это нужно, чтобы восстановить игру при очередном ходе. В принципе, можно проводить расчет поля по логу. Не реализованно, но возможно это было бы более выгодным решением.

## Нерешенные проблемы

Теоретически может возникнуть состояние гонки перед началом игры: первому игроку отправили уведомление, что можно начинать, а второму **после этого** отвечаем на его же запрос, на каком канале ему слушать отмашку. В итоге, если второй игрок не успеет подключиться на канал, он пропустит трансляцию хода первого игрока.

Решить это наверно можно искуственной паузой на самом первом ходе. И ставить эту паузу нужно на сервере, так как клиенты API могут быть разные и задержка - не их проблема.
